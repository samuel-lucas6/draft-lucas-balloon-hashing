{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2024-06-23T01:24:02.548244+00:00",
  "repo": "samuel-lucas6/draft-lucas-balloon-hashing",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "I_kwDOK_bi8M563z51",
      "title": "Use UInt64 instead of BigInteger",
      "url": "https://github.com/samuel-lucas6/draft-lucas-balloon-hashing/issues/1",
      "state": "CLOSED",
      "author": "samuel-lucas6",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "The `other` variable currently uses `BigInteger` before being converted to an `Int32`:\r\n\r\n```c#\r\nfor (int i = 0; i < delta; i++) {\r\n\tIntsToBlock(idxBlock, t, m, i);\r\n\tHash(idxBlock, counter++, salt, idxBlock);\r\n\tvar other = new BigInteger(idxBlock, isUnsigned: true, isBigEndian: false) % spaceCost;\r\n\tHash(buffer[m], counter++, buffer[m], buffer[(int)other]);\r\n}\r\n```\r\n\r\nThis is done for interoperability with [existing implementations](https://github.com/RustCrypto/password-hashes/pull/232), but it seems preferable to use `UInt64` like everywhere else. However, this would mean all implementations would have to be updated in line with the draft.",
      "createdAt": "2024-01-01T09:50:04Z",
      "updatedAt": "2024-05-12T13:54:41Z",
      "closedAt": "2024-05-12T13:54:41Z",
      "comments": []
    },
    {
      "number": 2,
      "id": "I_kwDOK_bi8M5630W8",
      "title": "Provide generic parameters/safe minimums",
      "url": "https://github.com/samuel-lucas6/draft-lucas-balloon-hashing/issues/2",
      "state": "OPEN",
      "author": "samuel-lucas6",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "[OWASP](https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html), [TobTu](https://tobtu.com/), the [Argon2 RFC](https://www.rfc-editor.org/rfc/rfc9106.html), etc provide recommended parameters. It would be good to do the same assuming they are realistic, but there's no guidance on parameters from the authors of Balloon. Furthermore, Balloon hasn't been benchmarked properly with different hash functions and parameters to determine suitable recommendations.",
      "createdAt": "2024-01-01T09:54:00Z",
      "updatedAt": "2024-06-19T01:20:30Z",
      "closedAt": null,
      "comments": [
        {
          "author": "Sc00bz",
          "authorAssociation": "NONE",
          "body": "The best way to do this is count the amount of hash block calculations and compare to PBKDF2 because a GPU attacker will be limited by compute instead of bandwidth. Balloon needs to use >1 MiB to start slowing down GPUs. >3 MiB will have a near linear slowdown.\r\n\r\nI'm going to use \"H/block\" to mean \"hash block calculations per block of memory\". This is how many hash blocks are calculated to output a hash. Depending on implementation and settings (I'll use \"delta\" or \"neighbors\" = 3). This is usually 3-17 H/block. Some bad implementations depend on salt length and worse depend on secret data and its length. Defender costs are [paper](https://eprint.iacr.org/2016/027.pdf) (14 H/block), [academic code](https://github.com/henrycg/balloon/blob/master/libballoon/hash_state.c#L145-L178) (3 H/block + 0.5 AES/block), [Rust's](https://github.com/RustCrypto/password-hashes/blob/master/balloon-hash/src/balloon.rs#L143-L201) (14-17+ H/block (depends on salt and secret data lengths)), [Python](https://github.com/nachonavarro/balloon-hashing/blob/master/balloon.py#L61-L94) (14-17+ H/block (depends on salt length)). Attacker costs are paper (8 H/block), academic code (3 H/block), Rust's (8 H/block), Python (8 H/block).\r\n\r\nRough settings for <10 KH/s/GPU (GPU being an RTX 4080 Super or \"2/3 of an RTX 4090\" which should be within a few percent of each other):\r\nBalloon-SHA-256:\r\nAcademic code: `m=256 KiB, t=48`; `m=512 KiB, t=24`; `m=1 MiB, t=12`; `m=2 MiB, t=3-6?`\r\nPaper/Rust's/Python: `m=256 KiB, t=18`; `m=512 KiB, t=9`; `m=1 MiB, t=5`; `m=2 MiB, t=2-3?`\r\n\r\nBalloon-SHA-512:\r\nAcademic code: `m=256 KiB, t=34`; `m=512 KiB, t=17`; `m=1 MiB, t=9`; `m=2 MiB, t=2-4?`\r\nPaper/Rust's/Python: `m=256 KiB, t=13`; `m=512 KiB, t=7`; `m=1 MiB, t=4`; `m=2 MiB, t=1-2?`\r\n\r\nI looked into what the best output size of SHAKE128 for max speed: 248, 520, 792, 1056, and 1328 are 1, 2, 3, 4, and 5 H/block. Best is SHAKE128 with 1328 bits of output but it's not a multiple of a cache line so 512 (2 H/block) or 1024 (4 H/block) would be better. But this puts it at about even with SHA-512 for the attacker. Now the only question is which is faster for the defender. SHAKE128-1024 might be faster even if it's slower than SHA-512 because of the larger block size. Also if the same hash function is used for the deterministic random lookups then SHAKE128-1024 will have an advantage when grabbing 64 bit at a time vs big int math. Note the \"academic code\" is SHA-256 for the hash and AES-128 for the deterministic random lookups. I just remembered that SHAKE128 has an internal parallelism of 5. Which means the slowdown for an attacker doesn't start until >5 MiB but to utilize that there's a performance hit. Yeah... I'll need to implement it to see where it lands. Not that I'm going to do that any time soon.",
          "createdAt": "2024-06-19T01:20:29Z",
          "updatedAt": "2024-06-19T01:20:29Z"
        }
      ]
    },
    {
      "number": 3,
      "id": "I_kwDOK_bi8M56304F",
      "title": "Should delta be fixed?",
      "url": "https://github.com/samuel-lucas6/draft-lucas-balloon-hashing/issues/3",
      "state": "CLOSED",
      "author": "samuel-lucas6",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "The current draft allows the `delta` parameter to be configured, but this parameter isn't very well explained in the [paper](https://eprint.iacr.org/2016/027) and adds confusion for the user. Some [existing implementations](https://github.com/RustCrypto/password-hashes/tree/master/balloon-hash) don't allow this parameter to be adjusted.",
      "createdAt": "2024-01-01T09:58:25Z",
      "updatedAt": "2024-05-12T11:29:54Z",
      "closedAt": "2024-05-12T11:29:54Z",
      "comments": [
        {
          "author": "samuel-lucas6",
          "authorAssociation": "OWNER",
          "body": "This will be fixed at 3 in the next version of the draft.",
          "createdAt": "2024-01-20T17:20:23Z",
          "updatedAt": "2024-01-20T17:20:23Z"
        }
      ]
    },
    {
      "number": 4,
      "id": "I_kwDOK_bi8M5632p5",
      "title": "Support key derivation properly",
      "url": "https://github.com/samuel-lucas6/draft-lucas-balloon-hashing/issues/4",
      "state": "CLOSED",
      "author": "samuel-lucas6",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Balloon has a limited output length, with the [paper](http://eprint.iacr.org/2016/027) only discussing it in terms of being a password hashing algorithm, not a password-based key derivation function. By contrast, [Wikipedia](https://en.wikipedia.org/wiki/Balloon_hashing) and [NIST](https://csrc.nist.gov/pubs/sp/800/63/b/upd2/final) call it a PBKDF.\r\n\r\nIt would be nice to have longer outputs, like with [scrypt](https://www.rfc-editor.org/rfc/rfc7914) and [Argon2](https://www.rfc-editor.org/rfc/rfc9106.html), without bringing in another primitive. For example, by doing something akin to [NIST's One-Step KDF](https://csrc.nist.gov/pubs/sp/800/56/c/r2/final) or [NIST's KDF in Feedback Mode](https://csrc.nist.gov/pubs/sp/800/108/r1/final). However, XOF functionality should be used when available like NIST's KDF using KMAC but for algorithms such as SHAKE and BLAKE3.\r\n\r\nLike #1, this would be a breaking change for existing implementations.",
      "createdAt": "2024-01-01T10:12:01Z",
      "updatedAt": "2024-05-19T08:47:18Z",
      "closedAt": "2024-05-19T08:47:17Z",
      "comments": []
    },
    {
      "number": 5,
      "id": "I_kwDOK_bi8M5633Pp",
      "title": "Treat Balloon as one algorithm",
      "url": "https://github.com/samuel-lucas6/draft-lucas-balloon-hashing/issues/5",
      "state": "CLOSED",
      "author": "samuel-lucas6",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Currently, Balloon and Balloon-M are both specified, with Balloon-M recommended if doing a cryptographic library implementation. I don't like algorithms with multiple variants as it complicates things, so perhaps only Balloon-M should be specified, with Balloon treated as an internal function like what [scrypt](https://www.rfc-editor.org/rfc/rfc7914#section-6) does with `scryptROMix`.",
      "createdAt": "2024-01-01T10:16:39Z",
      "updatedAt": "2024-05-12T11:24:37Z",
      "closedAt": "2024-05-12T11:24:37Z",
      "comments": [
        {
          "author": "samuel-lucas6",
          "authorAssociation": "OWNER",
          "body": "Balloon-M will be renamed to Balloon in the next version of the draft, and the current Balloon function will have to be renamed to something else (e.g. EME for Expand Mix Extract). This will leave one algorithm with support for parallelism.",
          "createdAt": "2024-01-20T17:22:55Z",
          "updatedAt": "2024-01-20T17:22:55Z"
        }
      ]
    },
    {
      "number": 6,
      "id": "I_kwDOK_bi8M56334O",
      "title": "Missing maximum constants",
      "url": "https://github.com/samuel-lucas6/draft-lucas-balloon-hashing/issues/6",
      "state": "CLOSED",
      "author": "samuel-lucas6",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "The parameters should have a maximum length like in the [Argon2 RFC](https://www.rfc-editor.org/rfc/rfc9106.html#section-3.1). `MAX_SPACECOST`, `MAX_TIMECOST`, `MAX_PARALLELISM`, and `MAX_DELTA` can be added as well as some for the password, salt, and output lengths.",
      "createdAt": "2024-01-01T10:21:35Z",
      "updatedAt": "2024-01-20T17:01:54Z",
      "closedAt": "2024-01-20T17:01:54Z",
      "comments": []
    },
    {
      "number": 7,
      "id": "I_kwDOK_bi8M5634V2",
      "title": "Support for a pepper",
      "url": "https://github.com/samuel-lucas6/draft-lucas-balloon-hashing/issues/7",
      "state": "OPEN",
      "author": "samuel-lucas6",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "A secret key could be supported like in [Argon2](https://www.rfc-editor.org/rfc/rfc9106.html#section-3.1). However, I'm not convinced this is a good idea because encrypting password hashes is [preferable](https://github.com/paragonie/password_lock?tab=readme-ov-file#how-is-this-different-than-peppering), as explained in the Security Considerations section. Supporting this would suggest otherwise, even though it could be useful for key derivation.",
      "createdAt": "2024-01-01T10:25:30Z",
      "updatedAt": "2024-06-22T11:35:07Z",
      "closedAt": null,
      "comments": [
        {
          "author": "Sc00bz",
          "authorAssociation": "NONE",
          "body": "I agree. But you might want to have \"extra salts\". This is useful for PAKEs where you include the user ID, server ID, OPRF salt (or salt), and local/secret salt (if there is one). This is just to avoid collisions for `H(salt || userId || serverId)` like `H(salt || \"user1\" || \"server\")` and `H(salt || \"user\" || \"1server\")` etc. It doesn't matter how you do it but the simplest is `salt' = H(H(salt) || H(userId) || H(serverId) || ... )`.",
          "createdAt": "2024-06-19T01:38:16Z",
          "updatedAt": "2024-06-19T01:38:16Z"
        },
        {
          "author": "samuel-lucas6",
          "authorAssociation": "OWNER",
          "body": "Could the user not just supply that via the existing salt parameter? They'd obviously have to do proper separation though like encoding the lengths.",
          "createdAt": "2024-06-20T16:43:19Z",
          "updatedAt": "2024-06-20T16:43:19Z"
        },
        {
          "author": "Sc00bz",
          "authorAssociation": "NONE",
          "body": "Yes, but having it as an option prevents the user of the API from needing to think about encoding lengths or other proper separation methods and maybe messing it up. Also it gives a common implemented method for this.",
          "createdAt": "2024-06-21T23:28:04Z",
          "updatedAt": "2024-06-21T23:28:04Z"
        },
        {
          "author": "samuel-lucas6",
          "authorAssociation": "OWNER",
          "body": "I hear you. I've not seen any other algorithm do this though. What would the API look like? An array of salts and you append the length of each one?\r\n\r\nAs mentioned in #14, it will probably be easy to support a pepper once the switch from `Hash()` to `PRF()` is made.",
          "createdAt": "2024-06-22T11:35:06Z",
          "updatedAt": "2024-06-22T11:35:06Z"
        }
      ]
    },
    {
      "number": 8,
      "id": "I_kwDOK_bi8M576e96",
      "title": "Reading about Balloon",
      "url": "https://github.com/samuel-lucas6/draft-lucas-balloon-hashing/issues/8",
      "state": "OPEN",
      "author": "samuel-lucas6",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "I won't understand everything, but I can perhaps try and summarise bits in the Security Considerations section or use findings to inform tweaks. There are [lots](https://eprint.iacr.org/archive/versions/2016/027) of versions of the Balloon paper, so I'm not going to attempt to identify the differences between each one.\r\n\r\n- [x] [Balloon Hashing: Provably Space-Hard Hash Functions with Data-Independent Access Patterns](https://eprint.iacr.org/archive/2016/027/20160114:175127) (original Balloon paper)\r\n- [x] [Balloon Hashing: A Memory-Hard Function Providing Provable Protection Against Sequential Attacks](https://eprint.iacr.org/2016/027) (newest Balloon paper)\r\n- [x] [Balloon Hashing Asiacrypt 2016 talk](https://youtu.be/7vs47CYnDsQ) ([slides](https://people.csail.mit.edu/henrycg/files/academic/pres/asiacrypt16balloon-slides.pdf))\r\n- [ ] [Proof of Space from Stacked Expanders](https://eprint.iacr.org/2016/333)\r\n- [x] [Towards Practical Attacks on Argon2i and Balloon Hashing](https://eprint.iacr.org/2016/759)\r\n- [ ] [Depth-Robust Graphs and Their Cumulative Memory Complexity](https://eprint.iacr.org/2016/875)\r\n- [x] [Depth Robust Graphs and Their Cumulative Memory Complexity Eurocrypt 2017 talk](https://youtu.be/K1BdGP2ffSI) ([slides](https://eurocrypt.iacr.org/2017/slides/B05-depth-robust.pdf))\r\n- [x] [Bandwidth Hard Functions for ASIC Resistance](https://eprint.iacr.org/2017/225)\r\n\r\n[Link](https://eprint.iacr.org/search?q=balloon&title=&authors=&category=&submittedafter=&submittedbefore=&revisedafter=&revisedbefore=) to the full search results on ePrint Archive.\r\n\r\n",
      "createdAt": "2024-01-12T14:10:52Z",
      "updatedAt": "2024-01-27T17:22:45Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 9,
      "id": "I_kwDOK_bi8M58s6qv",
      "title": "Fix the modulo bias",
      "url": "https://github.com/samuel-lucas6/draft-lucas-balloon-hashing/issues/9",
      "state": "CLOSED",
      "author": "samuel-lucas6",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "`spaceCost` can be required to be a power of two.",
      "createdAt": "2024-01-20T16:41:51Z",
      "updatedAt": "2024-05-18T10:55:13Z",
      "closedAt": "2024-05-18T10:55:13Z",
      "comments": [
        {
          "author": "samuel-lucas6",
          "authorAssociation": "OWNER",
          "body": "Another approach would be using UInt128 and doing NIST's [Simple Modular Method](https://crypto.stackexchange.com/a/50569). However, that goes against #1 unless UInt64 is replaced with UInt128 everywhere.",
          "createdAt": "2024-02-23T18:40:55Z",
          "updatedAt": "2024-02-23T18:40:55Z"
        }
      ]
    },
    {
      "number": 10,
      "id": "I_kwDOK_bi8M58s-1n",
      "title": "Create a release for the interoperable version",
      "url": "https://github.com/samuel-lucas6/draft-lucas-balloon-hashing/issues/10",
      "state": "CLOSED",
      "author": "samuel-lucas6",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Publishing an Internet-Draft for the version interoperable with current implementations will likely cause confusion when breaking changes are made to improve the algorithm. Therefore, I will create a GitHub release instead for future reference if people need backwards compatibility.",
      "createdAt": "2024-01-20T17:18:48Z",
      "updatedAt": "2024-05-12T11:03:34Z",
      "closedAt": "2024-05-12T11:03:34Z",
      "comments": []
    },
    {
      "number": 12,
      "id": "I_kwDOK_bi8M6JW9no",
      "title": "Prevent canonicalization attacks",
      "url": "https://github.com/samuel-lucas6/draft-lucas-balloon-hashing/issues/12",
      "state": "CLOSED",
      "author": "samuel-lucas6",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "The current concatenation of the password and salt means you can shift bytes between the two parameters and get the same output, which should not be possible.\r\n\r\nThe easiest way to fix this is to append the lengths. Technically, one length will do but both are normally included in practice (e.g., in AEAD schemes).",
      "createdAt": "2024-05-19T08:31:53Z",
      "updatedAt": "2024-05-19T08:50:19Z",
      "closedAt": "2024-05-19T08:50:19Z",
      "comments": []
    },
    {
      "number": 13,
      "id": "I_kwDOK_bi8M6JXD4m",
      "title": "Update the test vectors and encoded hash",
      "url": "https://github.com/samuel-lucas6/draft-lucas-balloon-hashing/issues/13",
      "state": "OPEN",
      "author": "samuel-lucas6",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Once the design has been finalised, these need to be updated since breaking changes have been made.",
      "createdAt": "2024-05-19T09:40:21Z",
      "updatedAt": "2024-05-19T09:40:22Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 14,
      "id": "I_kwDOK_bi8M6M3xDS",
      "title": "Fixes and suggestions",
      "url": "https://github.com/samuel-lucas6/draft-lucas-balloon-hashing/issues/14",
      "state": "OPEN",
      "author": "Sc00bz",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "https://github.com/samuel-lucas6/draft-lucas-balloon-hashing/blob/bfa686ed8e1bf5e3b81d35316ba27d5d23bea41b/draft-lucas-balloon-hashing.md?plain=1#L184\r\n`List` should be called `Array`. This can be called an array of arrays or 2D array. Maybe consider `ByteArray` and `BlockArray` which cover the two use cases.\r\n\r\n----\r\n\r\nhttps://github.com/samuel-lucas6/draft-lucas-balloon-hashing/blob/bfa686ed8e1bf5e3b81d35316ba27d5d23bea41b/draft-lucas-balloon-hashing.md?plain=1#L186-L187\r\nConsider making these 32 bit functions and keeping `LE64(x)` for `counter`. Since these are all defined as 32 bit max integers. Except `MAX_SPACECOST` but that's 0 which is less than `MIN_SPACECOST`. Also related:\r\nhttps://github.com/samuel-lucas6/draft-lucas-balloon-hashing/blob/bfa686ed8e1bf5e3b81d35316ba27d5d23bea41b/draft-lucas-balloon-hashing.md?plain=1#L218\r\nConsider making `spaceCost` an integer 0 to 32 and represents 2**`spaceCost` blocks of memory.\r\n\r\n----\r\n\r\nhttps://github.com/samuel-lucas6/draft-lucas-balloon-hashing/blob/bfa686ed8e1bf5e3b81d35316ba27d5d23bea41b/draft-lucas-balloon-hashing.md?plain=1#L189\r\nReplace \"integer\" with \"float\" or \"floating point\". Or remove \"the integer\".\r\n\r\n----\r\n\r\nhttps://github.com/samuel-lucas6/draft-lucas-balloon-hashing/blob/bfa686ed8e1bf5e3b81d35316ba27d5d23bea41b/draft-lucas-balloon-hashing.md?plain=1#L194\r\nAll mentions of XOF should be removed except this one because you are converting an XOF into a hash and this part might be missed. Also you are restricting XOFs more so than necessary. XOFs should not output more data than its internal state and should only call the internal base hash function the least amount of times to output anything (e.g. SHAKE128 has an internal state of 1600 bits but will call the internal base hash function more than the minimum for >1344 bits. Thus the max output for SHAKE128 is 1344 bits thus \"SHAKE128-1344\" or is it \"SHAKE128/1344\").\r\n\r\n----\r\n\r\nhttps://github.com/samuel-lucas6/draft-lucas-balloon-hashing/blob/bfa686ed8e1bf5e3b81d35316ba27d5d23bea41b/draft-lucas-balloon-hashing.md?plain=1#L240\r\nand\r\nhttps://github.com/samuel-lucas6/draft-lucas-balloon-hashing/blob/bfa686ed8e1bf5e3b81d35316ba27d5d23bea41b/draft-lucas-balloon-hashing.md?plain=1#L285\r\nConsider removing `LE64(length)`. For a KDF, let's say someone uses the exact output from Balloon then later realizes they need another key while preserving the original key. Then they would have to run Balloon twice, but if you remove `LE64(length)` then they can just ask for more output. Also in the Security Considerations section it should be stated to only run the password KDF once and derive all the keys needed from that output. Since an attacker will run which ever password KDF that will give them a password check (e.g. `encryptionKey = Balloon(...); macKey = Balloon(...);` and only do `macKey = Balloon(...); checkMac(macKey, mac, data)`).\r\n\r\n----\r\n\r\nhttps://github.com/samuel-lucas6/draft-lucas-balloon-hashing/blob/bfa686ed8e1bf5e3b81d35316ba27d5d23bea41b/draft-lucas-balloon-hashing.md?plain=1#L289-L294\r\nConsider changing this to:\r\n```\r\nprevious = buffer[spaceCost - 1]\r\nfor t = 0 to timeCost - 1\r\n    for m = 0 to spaceCost - 1\r\n```\r\nAnd add `previous = buffer[m]` to the end of the loop just after `buffer[m]` is set. A lot of implementations copied the paper verbatim on this or used an if statement. Also you can just return `previous`.\r\n\r\n----\r\n\r\nhttps://github.com/samuel-lucas6/draft-lucas-balloon-hashing/blob/bfa686ed8e1bf5e3b81d35316ba27d5d23bea41b/draft-lucas-balloon-hashing.md?plain=1#L296\r\nThis should be more like the academic code. Where it's a bit stream and you grab what you need from it. https://github.com/henrycg/balloon/blob/35d7da79f42b4f9078ba6f39e1e0a5a37bafa4c1/libballoon/hash_state.c#L167 Since `spaceCost` is a power of 2 you could grab the exact number of bits needed which will save calculations. Also reconsider including the salt because PAKEs with an OPRF will have a salt that includes the password (`oprfSalt = hash(password) ** serverSalt`). Maybe something like `Hash(LE64(counter++) || LE64(spaceCost) || LE64(timeCost) || LE64(parallelism) || LE64(iteration))`. Also the paper's version is `Hash(LE64(counter++) || salt || LE64(iteration))`. Unless you want the access pattern to be the same across all threads thus enabling SIMD and better bandwidth utilization (but there's no mention of this).\r\n\r\n----\r\n\r\nhttps://github.com/samuel-lucas6/draft-lucas-balloon-hashing/blob/bfa686ed8e1bf5e3b81d35316ba27d5d23bea41b/draft-lucas-balloon-hashing.md?plain=1#L305\r\nAdd:\r\n* `x % spaceCost` can be done with a bit mask `x & (spaceCost - 1)` because spaceCost is a power of 2.\r\n* Instead of `Ceiling(length / HASH_LEN)` one can do `Floor((length + HASH_LEN - 1) / HASH_LEN)` or `(length + HASH_LEN - 1) / HASH_LEN` where / is integer divide. (Side note: I've seen people include math.h and convert to and from floating points.)\r\n\r\n----\r\n\r\nhttps://github.com/samuel-lucas6/draft-lucas-balloon-hashing/blob/bfa686ed8e1bf5e3b81d35316ba27d5d23bea41b/draft-lucas-balloon-hashing.md?plain=1#L338\r\nSee https://github.com/samuel-lucas6/draft-lucas-balloon-hashing/issues/2#issuecomment-2177344918 Note the current draft is 3 H/block for an attacker which is the same for the \"academic code\" minimum settings.\r\n\r\n----\r\n\r\nhttps://github.com/samuel-lucas6/draft-lucas-balloon-hashing/blob/bfa686ed8e1bf5e3b81d35316ba27d5d23bea41b/draft-lucas-balloon-hashing.md?plain=1#L340\r\nOPRF salts are \"variable\" length based on elliptic curve or finite field prime. Also see https://github.com/samuel-lucas6/draft-lucas-balloon-hashing/issues/7#issuecomment-2177358941 about \"extra salts\". Also for password hashing this can be as low at like 32 bits unless you're Facebook scale then 40-48 bits. It's a whole thing about max collisions being relatively low and most are unique. BUT obviously there's not much difference in storage space than 128 bit salts.\r\n\r\n----\r\n\r\nhttps://github.com/samuel-lucas6/draft-lucas-balloon-hashing/blob/bfa686ed8e1bf5e3b81d35316ba27d5d23bea41b/draft-lucas-balloon-hashing.md?plain=1#L342\r\nFor password hashing, anything at least 80 bits is fine for anything properly key stretched but NIST would probably want at least 112 bits. BUT obviously there's not much difference in storage space than 128 bit hash. For key derivation, NIST recommends at least 112 bit (because of 3DES).\r\nAlso this contradicts at least 128 bits and at most 256 bits from:\r\nhttps://github.com/samuel-lucas6/draft-lucas-balloon-hashing/blob/bfa686ed8e1bf5e3b81d35316ba27d5d23bea41b/draft-lucas-balloon-hashing.md?plain=1#L374\r\n\r\n----\r\n\r\nhttps://github.com/samuel-lucas6/draft-lucas-balloon-hashing/blob/bfa686ed8e1bf5e3b81d35316ba27d5d23bea41b/draft-lucas-balloon-hashing.md?plain=1#L352\r\nvs\r\nhttps://github.com/samuel-lucas6/draft-lucas-balloon-hashing/blob/bfa686ed8e1bf5e3b81d35316ba27d5d23bea41b/draft-lucas-balloon-hashing.md?plain=1#L363\r\nShouldn't that be `$balloon-sha256$` or is it `blake2b-512`?\r\n\r\n----\r\n\r\nhttps://github.com/samuel-lucas6/draft-lucas-balloon-hashing/blob/bfa686ed8e1bf5e3b81d35316ba27d5d23bea41b/draft-lucas-balloon-hashing.md?plain=1#L376\r\n\"Similarly, systems MUST check for overly large user-specified parameters (e.g. passwords) to prevent denial-of-service attacks.\" That's only for poorly designed algorithms which Balloon should not be. Currently it hashes the password and salt `parallelism`+1 times. It would be better if it was just once or twice.\r\n\r\nThere are 3 steps to a good key stretching algorithm:\r\n1) Hash inputs: `seed = H(inputs); [seedNoSecrets = H(non-secret-inputs)]`\r\n2) Do work: `work = doWork(settings, seed[, seedNoSecrets])`\r\n3) Output: `out = kdf(work, (inputs or seed), outSize, ...)`\r\n\r\nOne can make a good key stretching algorithm without those steps. This just prevents bad design choices (CVE-2014-9034, CVE-2016-20013) and bad implementations (CVE-2013-1443).\r\n\r\n----\r\n\r\nhttps://github.com/samuel-lucas6/draft-lucas-balloon-hashing/blob/bfa686ed8e1bf5e3b81d35316ba27d5d23bea41b/draft-lucas-balloon-hashing.md?plain=1#L380\r\n\"authenticated encryption with associated data (AEAD) scheme\" No, authenticated is not needed since it's a password hash that can be replaced. It's more important to be deterministically encrypted. In fact this is the one time ECB is safe to use unless you want to store more than one blocks worth of hash. In that case use NULL-IV-CBC-CTS. This way you can have an HSM that only encrypts and the server can compare encrypted outputs. I just realized this doesn't mention that the only thing that needs to be encrypted is the hash part. Also it should be decoded into binary data before encrypted.\r\n\r\n----\r\n\r\nhttps://github.com/samuel-lucas6/draft-lucas-balloon-hashing/blob/bfa686ed8e1bf5e3b81d35316ba27d5d23bea41b/draft-lucas-balloon-hashing.md?plain=1#L382\r\nNIST would probably say at least 112 bits and at most 256 bits.\r\n\r\n----\r\n\r\nhttps://github.com/samuel-lucas6/draft-lucas-balloon-hashing/blob/bfa686ed8e1bf5e3b81d35316ba27d5d23bea41b/draft-lucas-balloon-hashing.md?plain=1#L392\r\nIt's more of a bandwidth vs memory transactions thing with GPUs. GPUs have wide memory buses. 128-384 bits for GeForce RTX 4000 series and Radeon RX 7000 series and historically up to 512 bits of GDDR. Other GPUs with HBM (vs GDDR) have bus widths of 1024 to 5120 bits.\r\n\r\n----\r\n\r\nhttps://github.com/samuel-lucas6/draft-lucas-balloon-hashing/blob/bfa686ed8e1bf5e3b81d35316ba27d5d23bea41b/draft-lucas-balloon-hashing.md?plain=1#L461\r\nTest Vector 4 has an invalid `spaceCost` of 3.",
      "createdAt": "2024-06-20T03:32:44Z",
      "updatedAt": "2024-06-22T11:31:05Z",
      "closedAt": null,
      "comments": [
        {
          "author": "samuel-lucas6",
          "authorAssociation": "OWNER",
          "body": "Hi Steve, thanks for your feedback; I'll definitely be giving you a mention in the Acknowledgements. I'll start working on these and do a proper reply at the weekend when I'm hopefully feeling fresh.\r\n\r\nSome of those things just haven't been updated whilst other parts have, like the test vectors. One major planned change is switching `Hash()` to `PRF()` to allow the use of HMAC. Then unkeyed hashes would use prefix MAC with the key padded to the block size. It's not ideal trying to cater for every possible hash function.",
          "createdAt": "2024-06-20T16:40:50Z",
          "updatedAt": "2024-06-20T16:40:50Z"
        },
        {
          "author": "Sc00bz",
          "authorAssociation": "NONE",
          "body": "> One major planned change is switching Hash() to PRF() to allow the use of HMAC.\r\n\r\nThis will make it slower and it's already slow. I guess this will only make it 33% slower (3 vs 4 H/block). Assuming cached HMAC.\r\n\r\n> Then unkeyed hashes would use prefix MAC with the key padded to the block size.\r\n\r\nAh this won't make it slower. Assuming the implementation caches the state after the key is added. Unlike CVE-2013-1443, PBKDF2 DoS with long password. Besides doing twice the work for normal sized passwords (4\\*iterations vs 2\\*iterations+2).",
          "createdAt": "2024-06-21T23:26:35Z",
          "updatedAt": "2024-06-21T23:26:35Z"
        },
        {
          "author": "samuel-lucas6",
          "authorAssociation": "OWNER",
          "body": "Big thanks for this again. There's some great stuff here.\r\n\r\n> List should be called Array. This can be called an array of arrays or 2D array. Maybe consider ByteArray and BlockArray which cover the two use cases.\r\n\r\nYes, that's a good idea.\r\n\r\n> Consider making these 32 bit functions and keeping LE64(x) for counter. Since these are all defined as 32 bit max integers. Except MAX_SPACECOST but that's 0 which is less than MIN_SPACECOST. Also related:\r\n\r\n`LE64()` was chosen for consistency everywhere, but I agree those could be switched to `LE32()`. The `MAX_` parameters were chosen to avoid the counter overflowing.\r\n\r\n> Consider making spaceCost an integer 0 to 32 and represents 2**spaceCost blocks of memory.\r\n\r\nThat's sensible now it's a power of 2.\r\n\r\n> Replace \"integer\" with \"float\" or \"floating point\". Or remove \"the integer\".\r\n\r\nHow about `the number x`?\r\n\r\n> All mentions of XOF should be removed except this one because you are converting an XOF into a hash and this part might be missed.\r\n\r\nFair point.\r\n\r\n> Also you are restricting XOFs more so than necessary. XOFs should not output more data than its internal state and should only call the internal base hash function the least amount of times to output anything (e.g. SHAKE128 has an internal state of 1600 bits but will call the internal base hash function more than the minimum for >1344 bits. Thus the max output for SHAKE128 is 1344 bits thus \"SHAKE128-1344\" or is it \"SHAKE128/1344\").\r\n\r\nI see what you mean. This was restricted for simplicity in terms of explaining what to do and because there are APIs where you use an XOF as a hash function. As an example, BLAKE3 can be used as a hash function or an XOF, which would lead to two incompatible variants for the same algorithm.\r\n\r\n> Consider removing LE64(length). For a KDF, let's say someone uses the exact output from Balloon then later realizes they need another key while preserving the original key. Then they would have to run Balloon twice, but if you remove LE64(length) then they can just ask for more output.\r\n\r\nI get you. This was inspired by Argon2's variable-length hash function.\r\n\r\n> Also in the Security Considerations section it should be stated to only run the password KDF once and derive all the keys needed from that output. Since an attacker will run which ever password KDF that will give them a password check (e.g. encryptionKey = Balloon(...); macKey = Balloon(...); and only do macKey = Balloon(...); checkMac(macKey, mac, data)).\r\n\r\nI agree. This is actually something I've been discussing with Henry because he proposed getting rid of the KDF and running Balloon repeatedly to generate more output like PBKDF2, which I've argued is a bad idea for this reason/because it reduces the parameters.\r\n\r\n> Consider changing this to:\r\n> previous = buffer[spaceCost - 1]\r\n> for t = 0 to timeCost - 1\r\n>     for m = 0 to spaceCost - 1\r\n> And add previous = buffer[m] to the end of the loop just after buffer[m] is set. A lot of implementations copied the paper verbatim on this or used an if statement. Also you can just return previous.\r\n\r\nGood spot. I'll rearrange this.\r\n\r\n> This should be more like the academic code. Where it's a bit stream and you grab what you need from it. https://github.com/henrycg/balloon/blob/35d7da79f42b4f9078ba6f39e1e0a5a37bafa4c1/libballoon/hash_state.c#L167 Since spaceCost is a power of 2 you could grab the exact number of bits needed which will save calculations.\r\n\r\nI'm not sure what you mean here. It's written as `pseudorandom = Hash(LE64(counter++) || salt)` because hash APIs output a full hash.\r\n\r\n> Also reconsider including the salt because PAKEs with an OPRF will have a salt that includes the password (oprfSalt = hash(password) ** serverSalt). Maybe something like Hash(LE64(counter++) || LE64(spaceCost) || LE64(timeCost) || LE64(parallelism) || LE64(iteration)).\r\n\r\nThat's an interesting point. That was just from the paper.\r\n\r\n> Also the paper's version is Hash(LE64(counter++) || salt || LE64(iteration)). Unless you want the access pattern to be the same across all threads thus enabling SIMD and better bandwidth utilization (but there's no mention of this).\r\n\r\n`iteration` was added recently rather than having domain separation in the salt, and I managed to miss that.\r\n\r\n> Add:\r\n> x % spaceCost can be done with a bit mask x & (spaceCost - 1) because spaceCost is a power of 2.\r\n> Instead of Ceiling(length / HASH_LEN) one can do Floor((length + HASH_LEN - 1) / HASH_LEN) or (length + HASH_LEN - 1) / HASH_LEN where / is integer divide. (Side note: I've seen people include math.h and convert to and from floating points.)\r\n\r\nI'll add those.\r\n\r\n> See https://github.com/samuel-lucas6/draft-lucas-balloon-hashing/issues/2#issuecomment-2177344918 Note the current draft is 3 H/block for an attacker which is the same for the \"academic code\" minimum settings.\r\n\r\nThanks for investigating that.\r\n\r\n> OPRF salts are \"variable\" length based on elliptic curve or finite field prime. Also see https://github.com/samuel-lucas6/draft-lucas-balloon-hashing/issues/7#issuecomment-2177358941 about \"extra salts\". Also for password hashing this can be as low at like 32 bits unless you're Facebook scale then 40-48 bits. It's a whole thing about max collisions being relatively low and most are unique. BUT obviously there's not much difference in storage space than 128 bit salts.\r\n\r\nYeah, I haven't thought about PAKEs at all. They're not something I've looked into, and it doesn't sound like they're frequently used. The 128 bits recommendation is following the Argon2 RFC.\r\n\r\n> For password hashing, anything at least 80 bits is fine for anything properly key stretched but NIST would probably want at least 112 bits. BUT obviously there's not much difference in storage space than 128 bit hash. For key derivation, NIST recommends at least 112 bit (because of 3DES).\r\n\r\nThe password hash length recommendation could be changed to 128 bits. I'd prefer to leave the key derivation recommendation as is. These are only recommendations, not MUSTs.\r\n\r\n> Also this contradicts at least 128 bits and at most 256 bits from:\r\n\r\nI don't think that does contradict anything because it's referring to the salt, which I've recommended 128 or 256 bits for before. SHOULD is equivalent to RECOMMENDED, and SHOULD NOT is equivalent to NOT RECOMMENDED, so they're not absolutes again.\r\n\r\n> Shouldn't that be $balloon-sha256$ or is it blake2b-512?\r\n\r\nYep, that hash needs to be updated. It was a SHA-256 example because the Rust implementation, which the draft was originally based on, used SHA-256 test vectors.\r\n\r\n> \"Similarly, systems MUST check for overly large user-specified parameters (e.g. passwords) to prevent denial-of-service attacks.\" That's only for poorly designed algorithms which Balloon should not be. Currently it hashes the password and salt parallelism+1 times. It would be better if it was just once or twice.\r\n\r\nYes, I see that now. That's what people have meant about prehashing the password. The password will only be hashed once when the algorithm is switched to being keyed.\r\n\r\n> \"authenticated encryption with associated data (AEAD) scheme\" No, authenticated is not needed since it's a password hash that can be replaced. It's more important to be deterministically encrypted. In fact this is the one time ECB is safe to use unless you want to store more than one blocks worth of hash. In that case use NULL-IV-CBC-CTS. This way you can have an HSM that only encrypts and the server can compare encrypted outputs. I just realized this doesn't mention that the only thing that needs to be encrypted is the hash part. Also it should be decoded into binary data before encrypted.\r\n\r\nI don't know how this is done in practice, but I've said AEAD schemes because they're more commonly used in general for encryption. I first heard about this idea from [password_lock](https://github.com/paragonie/password_lock), which claims to do authenticated encryption and I think encrypts a string. I can mention that only the hash needs to be encrypted.\r\n\r\n> NIST would probably say at least 112 bits and at most 256 bits.\r\n\r\nThis is only a recommendation, and if NIST wanted to approve this, they could make their own recommendations. I don't want to be recommending anything below 128 bits.\r\n\r\n> It's more of a bandwidth vs memory transactions thing with GPUs. GPUs have wide memory buses. 128-384 bits for GeForce RTX 4000 series and Radeon RX 7000 series and historically up to 512 bits of GDDR. Other GPUs with HBM (vs GDDR) have bus widths of 1024 to 5120 bits.\r\n\r\nYeah, I won't pretend to understand cache hardness. It could do with being properly defined and explained somewhere in the literature. It sounds like you need an understanding of GPU architecture.\r\n\r\n> Test Vector 4 has an invalid spaceCost of 3.\r\n\r\nThe test vectors are from the old Rust implementation so are out of date. They'll be updated when the design is finalised, and it would be good to have test vectors for all the major hash functions, although that will be a pain.\r\n\r\n> This will make it slower and it's already slow. I guess this will only make it 33% slower (3 vs 4 H/block). Assuming cached HMAC. \r\n\r\n> Ah this won't make it slower. Assuming the implementation caches the state after the key is added. Unlike https://github.com/advisories/GHSA-4c42-4rxm-x6qf, PBKDF2 DoS with long password. Besides doing twice the work for normal sized passwords (4*iterations vs 2*iterations+2).\r\n\r\nThe idea is to allow the use of HMAC because that's probably what NIST wants whilst allowing everyone else to use an ordinary hash function/non-approved algorithm instead (e.g., BLAKE2). It's not ideal though because of things like keyed BLAKE2/BLAKE3 vs prefix MAC for BLAKE2/BLAKE3, which may cause confusion/interoperability issues.\r\n\r\nThe plan is to do `key = PRF(emptyKey, password || salt || password.Length || salt.Length)` and then use that key as the key everywhere else, except when computing the pseudorandom bytes since that should be password-independent. That can use an empty key again. This isn't ideal with prefix MAC but is like HKDF-Extract with HMAC.\r\n\r\nThis would allow easily supporting a pepper because that initial `emptyKey` could be the pepper, and it would be restricted to something like 512 bits to avoid HMAC key hashing, which was a HMAC design flaw.",
          "createdAt": "2024-06-22T11:31:03Z",
          "updatedAt": "2024-06-22T11:31:03Z"
        }
      ]
    },
    {
      "number": 15,
      "id": "I_kwDOK_bi8M6NIim1",
      "title": "Rename the draft/algorithm to Balloon KDF (BKDF)",
      "url": "https://github.com/samuel-lucas6/draft-lucas-balloon-hashing/issues/15",
      "state": "OPEN",
      "author": "samuel-lucas6",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "1. The current naming is confusing because there's Balloon and Balloon Hashing, with the latter implying Balloon isn't a KDF.\r\n2. The design has been modified, so it makes sense to have a different name. Otherwise, people may think this is the same algorithm as other versions/variants.\r\n3. BKDF follows the same naming as PBKDF2 and HKDF in that it's an acronym.",
      "createdAt": "2024-06-22T13:31:46Z",
      "updatedAt": "2024-06-22T13:31:46Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 16,
      "id": "I_kwDOK_bi8M6NIjK_",
      "title": "Support using HMAC",
      "url": "https://github.com/samuel-lucas6/draft-lucas-balloon-hashing/issues/16",
      "state": "CLOSED",
      "author": "samuel-lucas6",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "`Hash(message)` can be replaced with `PRF(key, message)` to support the use of HMAC, which NIST would likely prefer. This then helps with only hashing the password once (discussed in #14) and adding a pepper (#7).\r\n\r\nHowever, to support ordinary hash functions still, prefix MAC can be used, padding the key to the block size to [induce a random IV](https://eprint.iacr.org/2010/264). When the hash function supports a key parameter (e.g., keyed BLAKE2), that can be used instead, which basically does the same thing internally.\r\n\r\nGeneration of the pseudorandom bytes won't use the same key to stay password-independent.",
      "createdAt": "2024-06-22T13:38:04Z",
      "updatedAt": "2024-06-22T14:11:31Z",
      "closedAt": "2024-06-22T14:11:31Z",
      "comments": []
    },
    {
      "number": 17,
      "id": "I_kwDOK_bi8M6NIj9X",
      "title": "Decide whether to keep parallelism",
      "url": "https://github.com/samuel-lucas6/draft-lucas-balloon-hashing/issues/17",
      "state": "OPEN",
      "author": "samuel-lucas6",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Argon2 and scrypt have a parallelism parameter, but it's [often not used](https://crypto.stackexchange.com/a/84085)/[recommended to stay at 1](https://github.com/Sc00bz/bscrypt?tab=readme-ov-file#settings) and [sometimes implemented serially](https://words.filippo.io/the-scrypt-parameters/). More parameters also means more confusion, like setting the cost parameter for bcrypt is much simpler than setting the parameters for memory-hard algorithms.\r\n\r\nOn the other hand, removing this parameter could affect interoperability, with people implementing parallelism themselves. It also doesn't add much code complexity.",
      "createdAt": "2024-06-22T13:46:47Z",
      "updatedAt": "2024-06-22T13:46:47Z",
      "closedAt": null,
      "comments": []
    }
  ],
  "pulls": [
    {
      "number": 11,
      "id": "PR_kwDOK_bi8M5nra-D",
      "title": "Add implementations for Dart, Julia, Kotlin, Ruby",
      "url": "https://github.com/samuel-lucas6/draft-lucas-balloon-hashing/pull/11",
      "state": "MERGED",
      "author": "elliotwutingfeng",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I've implemented Balloon in Dart, Julia, Kotlin, and Ruby. Mostly as programming exercises to familiarise myself with said languages. They are all direct ports of [nachonavarro/balloon-hashing](https://github.com/nachonavarro/balloon-hashing). Feel free to include them in the README.",
      "createdAt": "2024-02-22T18:11:59Z",
      "updatedAt": "2024-02-23T18:41:17Z",
      "baseRepository": "samuel-lucas6/draft-lucas-balloon-hashing",
      "baseRefName": "main",
      "baseRefOid": "de520e78f3fb57cbbbb5b150d9a5d39227c74f21",
      "headRepository": "elliotwutingfeng/draft-lucas-balloon-hashing",
      "headRefName": "patch-1",
      "headRefOid": "2b8021f9f66ad95136376375d3ff6b11c3aaf59c",
      "closedAt": "2024-02-23T18:33:58Z",
      "mergedAt": "2024-02-23T18:33:58Z",
      "mergedBy": "samuel-lucas6",
      "mergeCommit": {
        "oid": "aebec5f69d1fc31108afa098a5152143d2bab61b"
      },
      "comments": [
        {
          "author": "samuel-lucas6",
          "authorAssociation": "OWNER",
          "body": "Awesome, sorry I missed them.\r\n\r\nPlease keep an eye on this repository because there will eventually be breaking changes to the algorithm.",
          "createdAt": "2024-02-23T18:33:27Z",
          "updatedAt": "2024-02-23T18:33:27Z"
        }
      ],
      "reviews": []
    }
  ]
}